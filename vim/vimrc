" vim-plug
call plug#begin('~/.vim/plugged')
Plug 'michaeljsmith/vim-indent-object'
Plug 'tpope/vim-surround'
Plug 'jiangmiao/auto-pairs'
Plug 'easymotion/vim-easymotion'
Plug 'nelstrom/vim-visual-star-search'
Plug 'scrooloose/nerdcommenter'
Plug 'itchyny/lightline.vim'
Plug 'taohexxx/lightline-buffer'
Plug 'tpope/vim-fugitive'
Plug 'vimwiki/vimwiki'
Plug 'ap/vim-css-color'
Plug 'junegunn/seoul256.vim'
Plug 'shinchu/lightline-seoul256.vim'
Plug 'rstacruz/sparkup'
Plug 'peitalin/vim-jsx-typescript'
Plug 'MaxMEllon/vim-jsx-pretty'
Plug 'tomtom/tlib_vim'
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'tpope/vim-eunuch'
Plug 'chrisbra/unicode.vim'
Plug 'Shougo/vimproc.vim'
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'weirongxu/coc-explorer', {'do': 'yarn install --frozen-lockfile'}
Plug 'liuchengxu/vista.vim'
Plug 'neoclide/coc-snippets', {'do': 'yarn install --frozen-lockfile'}
Plug 'neoclide/coc-tsserver', {'do': 'yarn install --frozen-lockfile'}
Plug 'neoclide/coc-json', {'do': 'yarn install --frozen-lockfile'}
Plug 'iamcco/coc-flutter', {'do': 'yarn install --frozen-lockfile'}
Plug 'dart-lang/dart-vim-plugin'
Plug 'junegunn/fzf', { 'do': './install --bin' }
Plug 'junegunn/fzf.vim'
Plug 'junegunn/vim-easy-align'
Plug 'junegunn/goyo.vim'
Plug 'junegunn/limelight.vim'
call plug#end()

" general defaults setup
filetype plugin indent on
syntax on
let g:seoul256_background = 235
colorscheme seoul256
set t_ut= " fixes bg color in tmux
set number relativenumber
let mapleader=" "
set hidden
set history=100
set wrap
set tabstop=4 shiftwidth=4 expandtab smartindent autoindent
set hlsearch
set ignorecase smartcase " search case insensitive unless a capital is used
set cursorline
set showmatch
set splitbelow
set splitright
set mouse=nv " allows mouse interaction in normal/visual mode
set laststatus=2 " for lightline to work with only one screen
set showtabline=2  " always show tabline
set scrolloff=5
set updatetime=300
set shortmess+=c
set signcolumn=yes
set shell=/usr/bin/zsh

" use fd for FZF (respect .gitignore)
let $FZF_DEFAULT_COMMAND='fd --type f'

" don't ignore strings and comments with EasyAlign
let g:easy_align_ignore_groups = []

" if the directory for a new file doesn't exist, create it
augroup Mkdir
    autocmd!
    autocmd BufWritePre *
                \ if !isdirectory(expand("<afile>:p:h")) |
                \ call mkdir(expand("<afile>:p:h"), "p") |
                \ endif
augroup END

" compile pdf after saving tex file
autocmd BufWritePost *.tex !pdflatex %
let g:tex_flavor = "latex"

" custom tab config by file extension
autocmd BufRead,BufNewFile 
            \ *.html,*.css,*.js,*.jsx,*.ts,*.tsx,*.dart 
            \ setlocal tabstop=2 shiftwidth=2
autocmd BufRead,BufNewFile *.go setlocal noexpandtab

" break lines and enable spellcheck for document based files
autocmd BufRead,BufNewFile *.tex,*.md,*.wiki setlocal linebreak spell

set wildignore+=*/flask/*,*/.git/*,*/db_repository/*,*/node_modules/*

" key mappings
nnoremap <silent> <Esc> :nohlsearch<Bar>:echo<CR>
nnoremap <C-p> :FZF<CR>
nnoremap <C-b> :Buffers<CR>
nnoremap <leader>s :e!<CR>
nnoremap <leader>f :edit<space>
" open splits
nnoremap <leader>l :vsp<CR>
nnoremap <leader>h :rightb vsp<CR>
nnoremap <leader>j :bel split<CR>
nnoremap <leader>k :split<CR>
" navigate splits
nnoremap <C-l> <C-w>l
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w><C-w>
nnoremap <C-k> <C-w>W
" resize splits
nnoremap <M-h> <C-w><
nnoremap <M-j> <C-w>+
nnoremap <M-k> <C-w>-
nnoremap <M-l> <C-w>>
" reset resizings
nnoremap <leader>e <C-W>=
" navigate functions in a file
map [[ ?{<CR>w99[{<esc>
map ][ /}<CR>b99]}<esc>
map ]] j0[[%/{<CR><esc>
map [] k$][%?}<CR><esc>
" editor layout toggles
nnoremap <M-f> :CocCommand explorer<CR>
nnoremap <M-o> :Vista!!<CR>
nnoremap <M-t> :call MonkeyTerminalToggle()<CR>

let s:monkey_terminal_window = -1
let s:monkey_terminal_buffer = -1
let s:monkey_terminal_job_id = -1

" monkey terminal courtesy of https://gist.github.com/ram535/b1b7af6cd7769ec0481eb2eed549ea23
function! MonkeyTerminalToggle()
    if win_gotoid(s:monkey_terminal_window)
        call MonkeyTerminalClose()
    else
        call MonkeyTerminalOpen()
    endif
endfunction

function! MonkeyTerminalOpen()
    if !bufexists(s:monkey_terminal_buffer)
        new monkey_terminal
        wincmd J
        resize 10
        let s:monkey_terminal_job_id = termopen($SHELL, { 'detach': 1 })

        silent file Terminal\ 1
        let s:monkey_terminal_window = win_getid()
        let s:monkey_terminal_buffer = bufnr('%')

        set nobuflisted
    else
        if !win_gotoid(s:monkey_terminal_window)
            sp
            wincmd J   
            resize 10
            buffer Terminal\ 1
            let s:monkey_terminal_window = win_getid()
        endif
    endif
endfunction

function! MonkeyTerminalClose()
    if win_gotoid(s:monkey_terminal_window)
        hide
    endif
endfunction

nnoremap <C-s> :w<CR>
inoremap <C-s> <Esc>:w<CR>li
" nnoremap L $
" nnoremap H 0
" nnoremap J }
" nnoremap K {
" close buffer
nnoremap <C-q> :lclose<bar>b#<bar>bd #<CR>
" delete trailing whitespace in file
nnoremap <leader><BS> :%s/\s\+$//e<CR>
"nnoremap <C-r> :!make run<CR>
nnoremap Y y$
" format text into columns
vnoremap <leader>t :%!column -t<CR>
nnoremap U :redo<CR>
nnoremap gn :cn<CR>
nnoremap gN :cnf<CR>
nnoremap gp :cp<CR>
nnoremap gP :cpf<CR>
nnoremap <leader><leader>l :Goyo<CR>:Limelight!!<CR>

if has('nvim') " only run if using neovim
    au TermOpen * tnoremap <buffer> <Esc><Esc> <C-\><C-n>
    au FileType fzf tunmap <buffer> <Esc><Esc>
    au FileType fzf tnoremap <buffer> <Esc> <C-c>
    "tnoremap <C-h> <Left>
    "tnoremap <C-j> <Down>
    "tnoremap <C-k> <Up>
    "tnoremap <C-l> <Right>
endif

" lsp config
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <c-space> to trigger completion.
inoremap <silent><expr> <c-space> coc#refresh()

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current position.
" Coc only does snippet and additional edit on confirm.
inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" lsp normal mode remaps
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nmap <leader>cw <Plug>(coc-rename)
nnoremap <silent> K :call <SID>show_documentation()<CR>
imap <C-p> <C-o>:call CocActionAsync("showSignatureHelp")<CR>
nmap <leader>qf  <Plug>(coc-fix-current)

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Create mappings for function/class text objects
xmap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
omap af <Plug>(coc-funcobj-a)
xmap ic <Plug>(coc-classobj-i)
omap ic <Plug>(coc-classobj-i)
xmap ac <Plug>(coc-classobj-a)
omap ac <Plug>(coc-classobj-a)

" Use `:Format` to format current buffer
command! -nargs=0 Format :call CocAction('format')

let g:coc_node_path='/usr/bin/node'

function! LightlineFilename()
  let root = fnamemodify(get(b:, 'git_dir'), ':h')
  let path = expand('%:p')
  if path[:len(root)-1] ==# root
    return path[len(root)+1:]
  endif
  return expand('%')
endfunction

" use lightline-buffer in lightline
let g:lightline = {
            \ 'colorscheme': 'seoul256',
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'readonly', 'filename', 'modified' ] ],
            \   'right': [ [ 'lineinfo' ], [ 'percent' ],
            \              [ 'cocstatus', 'gitbranch', 'filetype' ] ],
            \ },
            \ 'tabline': {
            \ 'left': [ [], [ 'bufferbefore', 'buffercurrent', 'bufferafter' ] ],
            \ 'right': [],
            \ },
            \ 'component_expand': {
            \   'buffercurrent': 'lightline#buffer#buffercurrent',
            \   'bufferbefore': 'lightline#buffer#bufferbefore',
            \   'bufferafter': 'lightline#buffer#bufferafter',
            \ },
            \ 'component_type': {
            \   'buffercurrent': 'tabsel',
            \   'bufferbefore': 'raw',
            \   'bufferafter': 'raw',
            \ },
            \ 'component_function': {
            \   'bufferinfo': 'lightline#buffer#bufferinfo',
            \   'filename': 'LightlineFilename',
            \   'gitbranch': 'fugitive#head',
            \   'cocstatus': 'coc#status',
            \ },
            \ }

" update lightline on coc update
autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()

" lightline-buffer ui settings
" replace these symbols with ascii characters if your environment does not support unicode
let g:lightline_buffer_logo = '(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ '
let g:lightline_buffer_readonly_icon = ''
let g:lightline_buffer_modified_icon = '●'
let g:lightline_buffer_git_icon = ' '
let g:lightline_buffer_ellipsis_icon = '...'
let g:lightline_buffer_expand_left_icon = '◀ '
let g:lightline_buffer_expand_right_icon = ' ▶'
let g:lightline_buffer_active_buffer_right_icon = ''
let g:lightline_buffer_separator_icon = ' '

" lightline-buffer function settings
let g:lightline_buffer_show_bufnr = 1
let g:lightline_buffer_rotate = 0
let g:lightline_buffer_fname_mod = ':t'
let g:lightline_buffer_excludes = ['vimfiler']
let g:lightline_buffer_maxflen = 30
let g:lightline_buffer_maxfextlen = 3
let g:lightline_buffer_minflen = 16
let g:lightline_buffer_minfextlen = 3
let g:lightline_buffer_reservelen = 20
