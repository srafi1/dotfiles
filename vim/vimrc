" vim-plug
call plug#begin('~/.vim/plugged')
Plug 'michaeljsmith/vim-indent-object'
Plug 'wellle/targets.vim'
Plug 'terryma/vim-expand-region'
Plug 'tpope/vim-surround'
Plug 'jiangmiao/auto-pairs'
Plug 'easymotion/vim-easymotion'
Plug 'nelstrom/vim-visual-star-search'
Plug 'tomtom/tcomment_vim'
Plug 'tpope/vim-fugitive'
Plug 'vimwiki/vimwiki'
Plug 'ap/vim-css-color'
Plug 'junegunn/seoul256.vim'
Plug 'itchyny/lightline.vim'
Plug 'shinchu/lightline-seoul256.vim'
Plug 'rstacruz/sparkup'
Plug 'peitalin/vim-jsx-typescript'
Plug 'MaxMEllon/vim-jsx-pretty'
Plug 'tomtom/tlib_vim'
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'tpope/vim-eunuch'
Plug 'chrisbra/unicode.vim'
Plug 'Shougo/vimproc.vim'
Plug 'puremourning/vimspector'
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'weirongxu/coc-explorer', {'do': 'yarn install --frozen-lockfile'}
Plug 'liuchengxu/vista.vim'
Plug 'neoclide/coc-snippets', {'do': 'yarn install --frozen-lockfile'}
Plug 'neoclide/coc-tsserver', {'do': 'yarn install --frozen-lockfile'}
Plug 'neoclide/coc-json', {'do': 'yarn install --frozen-lockfile'}
Plug 'iamcco/coc-flutter', {'do': 'yarn install --frozen-lockfile'}
Plug 'dart-lang/dart-vim-plugin'
Plug 'junegunn/fzf', { 'do': './install --bin' }
Plug 'junegunn/fzf.vim'
Plug 'stsewd/fzf-checkout.vim'
Plug 'junegunn/vim-easy-align'
Plug 'junegunn/goyo.vim'
Plug 'junegunn/limelight.vim'
call plug#end()

" general defaults setup
let g:seoul256_background = 235
colorscheme seoul256
filetype plugin indent on
syntax on
set number relativenumber
let mapleader=" "
set hidden
set history=100
set wrap
set tabstop=4 shiftwidth=4 expandtab smartindent autoindent
set hlsearch
set ignorecase smartcase " search case insensitive unless a capital is used
set cursorline
set showmatch
set splitbelow
set splitright
set mouse=nv " allows mouse interaction in normal/visual mode
set scrolloff=3
set updatetime=300
set shortmess+=c
set signcolumn=yes
set shell=/usr/bin/zsh
set wildignore+=*/flask/*,*/.git/*,*/db_repository/*,*/node_modules/*

" use fd for FZF (respect .gitignore)
let $FZF_DEFAULT_COMMAND='fd --type f'
" do not force delete branch
let g:fzf_checkout_delete_execute = 'echo system("{git} branch -d {branch}")'

if exists(':terminal') " only run if using neovim
    au TermOpen * tnoremap <buffer> <Esc><Esc> <C-\><C-n>
    au FileType fzf tunmap <buffer> <Esc><Esc>
    au FileType fzf tnoremap <buffer> <Esc> <C-c>
endif

" don't ignore strings and comments with EasyAlign
let g:easy_align_ignore_groups = []

" if the directory for a new file doesn't exist, create it
augroup Mkdir
    autocmd!
    autocmd BufWritePre *
                \ if !isdirectory(expand("<afile>:p:h")) |
                \ call mkdir(expand("<afile>:p:h"), "p") |
                \ endif
augroup END

" compile pdf after saving tex file
autocmd BufWritePost *.tex !pdflatex %
let g:tex_flavor = "latex"

" custom tab config by file extension
autocmd BufRead,BufNewFile 
            \ *.html,*.css,*.js,*.jsx,*.ts,*.tsx,*.dart 
            \ setlocal tabstop=2 shiftwidth=2
autocmd BufRead,BufNewFile *.go setlocal noexpandtab

" break lines and enable spellcheck for document based files
autocmd BufRead,BufNewFile *.tex,*.md,*.wiki setlocal linebreak spell

" Vimspector function key keybindings
let g:vimspector_enable_mappings = 'HUMAN'

" key mappings
nnoremap <silent> <Esc> :nohlsearch<Bar>:echo<CR>
nnoremap U :redo<CR>
nnoremap Y y$
" navigate functions in a file
map [[ ?{<CR>w99[{<esc>
map ][ /}<CR>b99]}<esc>
map ]] j0[[%/{<CR><esc>
map [] k$][%?}<CR><esc>
nnoremap <C-p> :FZF<CR>
nnoremap <C-b> :Buffers<CR>
" reload file
nnoremap <leader>s :e!<CR>
" open splits
nnoremap <leader>l :vsp<CR>
nnoremap <leader>h :rightb vsp<CR>
nnoremap <leader>j :bel split<CR>
nnoremap <leader>k :split<CR>
" navigate splits
nnoremap <C-l> <C-w>l
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w><C-w>
nnoremap <C-k> <C-w>W
" resize splits
nnoremap <M-h> <C-w><
nnoremap <M-j> <C-w>+
nnoremap <M-k> <C-w>-
nnoremap <M-l> <C-w>>
nnoremap <M-e> <C-W>=
" save file
nnoremap <C-s> :w<CR>
inoremap <C-s> <C-o>:w<CR>
" close buffer
nnoremap <C-q> :lclose<bar>b#<bar>bd #<CR>
" delete trailing whitespace in file
nnoremap <leader><BS> :%s/\s\+$//e<CR>
" format text into columns
vnoremap <leader>t :%!column -t<CR>
" view unsaved edits in current buffer
nnoremap <leader>d :w !diff % -<CR>
" navigate quickfix list
nnoremap gn :cn<CR>
nnoremap gN :cnf<CR>
nnoremap gp :cp<CR>
nnoremap gP :cpf<CR>
" goyo and limelight for writing
nnoremap <leader><leader>l :Goyo<CR>:Limelight!!<CR>
" toggle editor layout
nnoremap <silent> <M-f> :CocCommand explorer<CR>
nnoremap <silent> <M-o> :Vista!!<CR>
nnoremap <silent> <M-t> :call MonkeyTerminalToggle()<CR>

let s:monkey_terminal_window = -1
let s:monkey_terminal_buffer = -1
let s:monkey_terminal_job_id = -1

" monkey terminal courtesy of https://gist.github.com/ram535/b1b7af6cd7769ec0481eb2eed549ea23
function! MonkeyTerminalToggle()
    if win_gotoid(s:monkey_terminal_window)
        call MonkeyTerminalClose()
    else
        call MonkeyTerminalOpen()
    endif
endfunction

function! MonkeyTerminalOpen()
    if !bufexists(s:monkey_terminal_buffer)
        new monkey_terminal
        wincmd J
        resize 10
        let s:monkey_terminal_job_id = termopen($SHELL, { 'detach': 1 })
        silent file Terminal\ 1
        let s:monkey_terminal_window = win_getid()
        let s:monkey_terminal_buffer = bufnr('%')
        set nobuflisted
    else
        if !win_gotoid(s:monkey_terminal_window)
            sp
            wincmd J   
            resize 10
            buffer Terminal\ 1
            let s:monkey_terminal_window = win_getid()
        endif
    endif
endfunction

function! MonkeyTerminalClose()
    if win_gotoid(s:monkey_terminal_window)
        hide
    endif
endfunction

" lsp config
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" trigger completion menu
inoremap <silent><expr> <c-space> coc#refresh()
" accept completion
inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" lsp normal mode remaps
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nmap <leader>cc :CocCommand<CR>
nmap <leader>ca :CocAction<CR>
vmap <leader>ca :CocAction<CR>
nmap <leader>cla <Plug>(coc-codelens-action)
nmap <leader>cw <Plug>(coc-rename)
nnoremap <silent> K :call <SID>show_documentation()<CR>
imap <C-p> <C-o>:call CocActionAsync("showSignatureHelp")<CR>
nmap <leader>qf  <Plug>(coc-fix-current)

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" function/class text objects
xmap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
omap af <Plug>(coc-funcobj-a)
xmap ic <Plug>(coc-classobj-i)
omap ic <Plug>(coc-classobj-i)
xmap ac <Plug>(coc-classobj-a)
omap ac <Plug>(coc-classobj-a)

" format current buffer
command! -nargs=0 Format :call CocAction('format')

let g:coc_node_path='/usr/bin/node'

function! LightlineFilename()
  let root = fnamemodify(get(b:, 'git_dir'), ':h')
  let path = expand('%:p')
  if path[:len(root)-1] ==# root
    return path[len(root)+1:]
  endif
  return expand('%')
endfunction

" use lightline-buffer in lightline
let g:lightline = {
            \ 'colorscheme': 'seoul256',
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'readonly', 'filename', 'modified' ] ],
            \   'right': [ [ 'lineinfo' ], [ 'gitbranch' ],
            \              [ 'cocstatus', 'filetype' ] ],
            \ },
            \ 'component_function': {
            \   'filename': 'LightlineFilename',
            \   'gitbranch': 'fugitive#head',
            \   'cocstatus': 'coc#status',
            \ },
            \ }

" update lightline on coc update
autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()
