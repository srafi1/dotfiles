" vim-plug
call plug#begin('~/.vim/plugged')
Plug 'michaeljsmith/vim-indent-object'
Plug 'wellle/targets.vim'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'jiangmiao/auto-pairs'
Plug 'nelstrom/vim-visual-star-search'
Plug 'tomtom/tcomment_vim'
Plug 'tpope/vim-fugitive'
Plug 'vimwiki/vimwiki'
Plug 'junegunn/seoul256.vim'
Plug 'itchyny/lightline.vim'
Plug 'shinchu/lightline-seoul256.vim'
Plug 'tpope/vim-eunuch'
Plug 'chrisbra/unicode.vim'
Plug 'puremourning/vimspector'
Plug 'justinmk/vim-dirvish'
Plug 'liuchengxu/vista.vim'
Plug 'junegunn/fzf', { 'do': './install --bin' }
Plug 'junegunn/fzf.vim'
Plug 'stsewd/fzf-checkout.vim'
Plug 'junegunn/vim-easy-align'
Plug 'junegunn/goyo.vim'
Plug 'junegunn/limelight.vim'
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
Plug 'itchyny/vim-qfedit'
Plug 'akinsho/nvim-toggleterm.lua'
Plug 'neovim/nvim-lspconfig'
Plug 'nvim-lua/completion-nvim'
Plug 'SirVer/ultisnips'
Plug 'nvim-lua/lsp-status.nvim'
call plug#end()

" general defaults setup
let g:seoul256_background = 235
silent! colorscheme seoul256
filetype plugin indent on
syntax on
set number relativenumber
let mapleader=" "
set hidden
set history=100
set wrap
set tabstop=4 shiftwidth=4 expandtab smartindent autoindent
set hlsearch
set ignorecase smartcase " search case insensitive unless a capital is used
set cursorline
set showmatch
set splitbelow
set splitright
set mouse=nv " allows mouse interaction in normal/visual mode
set scrolloff=3
set updatetime=300
set shortmess+=c
set signcolumn=yes
set shell=/usr/bin/zsh
set wildignore+=*/flask/*,*/.git/*,*/db_repository/*,*/node_modules/*

" use fd for FZF (respect .gitignore)
let $FZF_DEFAULT_COMMAND='fd --type f'
" do not force delete branch
let g:fzf_branch_actions = {
            \ 'delete': {
            \   'execute': 'echo system("{git} branch -d {branch}")'
            \ }
            \}

if exists(':terminal')
    au TermOpen * tnoremap <buffer> <Esc><Esc> <C-\><C-n>
    au FileType fzf tunmap <buffer> <Esc><Esc>
    au FileType fzf tnoremap <buffer> <Esc> <C-c>
endif

" don't ignore strings and comments with EasyAlign
let g:easy_align_ignore_groups = []

" if the directory for a new file doesn't exist, create it
augroup Mkdir
    autocmd!
    autocmd BufWritePre *
                \ if !isdirectory(expand("<afile>:p:h")) |
                \ call mkdir(expand("<afile>:p:h"), "p") |
                \ endif
augroup END

" compile pdf after saving tex file
autocmd BufWritePost *.tex !pdflatex %
let g:tex_flavor = "latex"

" custom tab config by file extension
autocmd BufRead,BufNewFile 
            \ *.html,*.css,*.js,*.jsx,*.ts,*.tsx,*.dart 
            \ setlocal tabstop=2 shiftwidth=2
autocmd BufRead,BufNewFile *.go setlocal noexpandtab

" break lines and enable spellcheck for document based files
autocmd BufRead,BufNewFile *.tex,*.md,*.mdx,*.wiki,*.txt call WritingMode()
function! WritingMode()
    setlocal linebreak spell
    nnoremap <buffer> j gj
    nnoremap <buffer> k gk
endfunction
autocmd BufRead,BufNewFile *.wiki nnoremap <buffer> <leader>d o<Esc>:r! date "+\%Y-\%m-\%d"<CR> 

" Vimspector function key keybindings
let g:vimspector_enable_mappings = 'HUMAN'

" key mappings
nnoremap <silent> <Esc> :nohlsearch<Bar>:echo<CR>
nnoremap U :redo<CR>
nnoremap Y y$
" paste without overwriting default register
vnoremap <leader>p "_dP
nnoremap <leader>p :set opfunc=ReplaceMotion<CR>g@
function! ReplaceMotion(type)
    silent exe "normal! `[v`]\"_dP"
endfunction
" navigate functions in a file
map [[ ?{<CR>w99[{<esc>
map ][ /}<CR>b99]}<esc>
map ]] j0[[%/{<CR><esc>
map [] k$][%?}<CR><esc>
nnoremap <C-p> :FZF<CR>
nnoremap <C-b> :Buffers<CR>
" reload file
nnoremap <leader>s :e!<CR>
" resize splits
nnoremap <M-h> <C-w><
nnoremap <M-j> <C-w>+
nnoremap <M-k> <C-w>-
nnoremap <M-l> <C-w>>
nnoremap <M-e> <C-W>=
" save file
nnoremap <C-s> :w<CR>
inoremap <C-s> <C-o>:w<CR>
" close buffer
nnoremap <C-q> :lclose<bar>b#<bar>bd #<CR>
" delete trailing whitespace in file
nnoremap <leader><BS> :%s/\s\+$//e<CR>
" format text into columns
vnoremap <leader>t :%!column -t<CR>
" view unsaved edits in current buffer
nnoremap <leader>d :w !diff % -<CR>
" navigate quickfix list
nnoremap gn :cn<CR>
nnoremap gN :cnf<CR>
nnoremap gp :cp<CR>
nnoremap gP :cpf<CR>
" goyo and limelight for writing
nnoremap <leader><leader>l :Goyo<CR>:Limelight!!<CR>
" toggle editor layout
nnoremap <silent> <M-o> :Vista!!<CR>

" -------------------- LSP ---------------------------------
:lua << EOF
  local lsp_status = require('lsp-status')
  lsp_status.register_progress()
  lsp_status.config({
    current_function = false,
    status_symbol = '',
    indicator_errors = 'E',
    indicator_warnings = 'W',
    indicator_info = 'I',
    indicator_hint = 'H',
    indicator_ok = '✔️',
    spinner_frames = { '⣾', '⣽', '⣻', '⢿', '⡿', '⣟', '⣯', '⣷' },
  })

  local nvim_lsp = require('lspconfig')

  local on_attach = function(client, bufnr)
    lsp_status.on_attach(client)

    require('completion').on_attach()

    local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
    local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

    buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

    -- Mappings
    local opts = { noremap=true, silent=true }
    buf_set_keymap('n', 'gD', '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
    buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
    buf_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
    buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
    buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
    buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
    buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
    buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
    buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
    buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
    buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
    buf_set_keymap('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
    buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
    buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
    buf_set_keymap('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)

    -- Set some keybinds conditional on server capabilities
    if client.resolved_capabilities.document_formatting then
        buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
    elseif client.resolved_capabilities.document_range_formatting then
        buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
    end
  end

  local servers = {'pyls', 'gopls', 'ccls', 'texlab', 'tsserver'}
  for _, lsp in ipairs(servers) do
    nvim_lsp[lsp].setup({
      on_attach = on_attach,
      capabilities = lsp_status.capabilities,
    })
  end

  -- diagnostics
  vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
    vim.lsp.diagnostic.on_publish_diagnostics, {
      virtual_text = false,
    }
  )
EOF

" diagnostics sign/highlight definitions
sign define LspDiagnosticsSignWarning     text=>> texthl=WarningMsg
sign define LspDiagnosticsSignError       text=>> texthl=Exception
sign define LspDiagnosticsSignInformation text=?
sign define LspDiagnosticsSignHint        text=~

" Completion
autocmd BufEnter * lua require'completion'.on_attach()
set completeopt=menuone,noinsert,noselect
let g:completion_matching_strategy_list = ['exact', 'substring', 'fuzzy']
let g:completion_enable_snippet = 'UltiSnips'
let g:UltiSnipsExpandTrigger=""
let g:completion_chain_complete_list = {
    \'default' : [
    \    {'complete_items': ['lsp', 'snippet', 'path']},
    \]
    \}
imap <silent> <c-space> <Plug>(completion_trigger)
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
" -------------------- LSP ---------------------------------

function! LightlineFilename()
  let root = fnamemodify(get(b:, 'git_dir'), ':h')
  let path = expand('%:p')
  if path[:len(root)-1] ==# root
    return path[len(root)+1:]
  endif
  return expand('%')
endfunction

function! LspStatus() abort
  if luaeval('#vim.lsp.buf_get_clients() > 0')
    return luaeval("require('lsp-status').status()")
  endif
  return ''
endfunction

" use lightline-buffer in lightline
let g:lightline = {
            \ 'colorscheme': 'seoul256',
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'gitbranch', 'filename' ],
            \             [ 'readonly', 'modified' ] ],
            \   'right': [ [ 'lineinfo' ], 
            \              [ 'cocstatus', 'filetype' ] ],
            \ },
            \ 'component_function': {
            \   'filename': 'LightlineFilename',
            \   'gitbranch': 'fugitive#head',
            \   'cocstatus': 'LspStatus',
            \ },
            \ 'component': {
            \   'lineinfo': "%{line('.') . '/' . line('$')}"
            \ }
            \ }

" update lightline on coc update
autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()

" treesitter setup
lua <<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "maintained", -- one of "all", "maintained" (parsers with maintainers), or a list of languages
  highlight = {
    enable = true,              -- false will disable the whole extension
    disable = { "c", "rust" },  -- list of language that will be disabled
  },
}
require"toggleterm".setup{
  size = 10,
  open_mapping = '<M-t>',
  persist_size = true,
}
EOF
